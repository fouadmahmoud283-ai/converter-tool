/**
 * Prisma ORM templates for self-hosted database
 */

import type { SelfHostedConfig } from '../config.js';

export interface PrismaOptions {
  config: SelfHostedConfig;
  additionalModels?: string;
}

/**
 * Generate Prisma schema with User, RefreshToken, and FileStorage models
 */
export function generatePrismaSchema(options: PrismaOptions): string {
  const { config } = options;
  const additionalModels = options.additionalModels || '';
  
  return `// Prisma Schema for Self-Hosted Backend
// Generated by Deno-Express Converter

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// Authentication Models
// ============================================

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  passwordHash  String    @map("password_hash")
  emailVerified Boolean   @default(false) @map("email_verified")
  
  // Profile fields
  fullName      String?   @map("full_name")
  avatarUrl     String?   @map("avatar_url")
  
  // Metadata (JSON field for flexible data)
  metadata      Json      @default("{}")
  
  // Timestamps
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")
  lastSignInAt  DateTime? @map("last_sign_in_at")
  
  // Relations
  refreshTokens RefreshToken[]
  files         FileStorage[]
  
  @@map("users")
}

model RefreshToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String   @map("user_id")
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")
  
  // Device/Session info
  userAgent String?  @map("user_agent")
  ipAddress String?  @map("ip_address")
  
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
  @@index([expiresAt])
  @@map("refresh_tokens")
}

// ============================================
// File Storage Models
// ============================================

model FileStorage {
  id          String   @id @default(cuid())
  bucket      String   @default("default")
  path        String
  filename    String
  mimeType    String   @map("mime_type")
  size        Int
  
  // Storage provider info
  provider    String   @default("local") // 'local' or 'minio'
  storageKey  String   @map("storage_key") // actual file path/key
  
  // Ownership
  userId      String?  @map("user_id")
  user        User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  
  // Access control
  isPublic    Boolean  @default(false) @map("is_public")
  
  // Timestamps
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")
  
  @@unique([bucket, path, filename])
  @@index([userId])
  @@index([bucket])
  @@map("file_storage")
}

// ============================================
// Session Model (for server-side sessions)
// ============================================

model Session {
  id        String   @id @default(cuid())
  userId    String   @map("user_id")
  data      Json     @default("{}")
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")
  
  @@index([userId])
  @@index([expiresAt])
  @@map("sessions")
}

${additionalModels}
`;
}

/**
 * Generate DATABASE_URL from config
 */
export function generateDatabaseUrl(config: SelfHostedConfig): string {
  const db = config.database || {};
  const host = db.host || 'localhost';
  const port = db.port || 5432;
  const name = db.name || 'app_db';
  const user = db.user || 'postgres';
  const password = db.password || 'postgres';
  
  return `postgresql://${user}:${password}@${host}:${port}/${name}?schema=public`;
}

/**
 * Generate Prisma client initialization code
 */
export function generatePrismaClient(): string {
  return `import { PrismaClient } from '@prisma/client';

// Global Prisma client instance (prevents multiple instances in development)
declare global {
  var __prisma: PrismaClient | undefined;
}

const prismaClientSingleton = () => {
  return new PrismaClient({
    log: process.env.NODE_ENV === 'development' 
      ? ['query', 'error', 'warn'] 
      : ['error'],
  });
};

export const prisma = globalThis.__prisma ?? prismaClientSingleton();

if (process.env.NODE_ENV !== 'production') {
  globalThis.__prisma = prisma;
}

// Graceful shutdown
process.on('beforeExit', async () => {
  await prisma.$disconnect();
});

export default prisma;
`;
}

/**
 * Generate database helper utilities
 */
export function generateDbUtils(): string {
  return `import prisma from './prisma.js';

/**
 * Health check for database connection
 */
export async function checkDatabaseHealth(): Promise<boolean> {
  try {
    await prisma.$queryRaw\`SELECT 1\`;
    return true;
  } catch (error) {
    console.error('Database health check failed:', error);
    return false;
  }
}

/**
 * Paginated query helper
 */
export interface PaginationOptions {
  page?: number;
  pageSize?: number;
  maxPageSize?: number;
}

export interface PaginatedResult<T> {
  data: T[];
  pagination: {
    page: number;
    pageSize: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };
}

export function getPaginationParams(options: PaginationOptions = {}) {
  const page = Math.max(1, options.page || 1);
  const maxSize = options.maxPageSize || 100;
  const pageSize = Math.min(Math.max(1, options.pageSize || 20), maxSize);
  
  return {
    skip: (page - 1) * pageSize,
    take: pageSize,
    page,
    pageSize,
  };
}

export function createPaginatedResult<T>(
  data: T[],
  total: number,
  page: number,
  pageSize: number
): PaginatedResult<T> {
  const totalPages = Math.ceil(total / pageSize);
  
  return {
    data,
    pagination: {
      page,
      pageSize,
      total,
      totalPages,
      hasNext: page < totalPages,
      hasPrev: page > 1,
    },
  };
}

/**
 * Transaction helper with automatic rollback on error
 */
export async function withTransaction<T>(
  fn: (tx: typeof prisma) => Promise<T>
): Promise<T> {
  return prisma.$transaction(async (tx) => {
    return fn(tx as typeof prisma);
  });
}
`;
}

/**
 * Generate generic CRUD service template
 */
export function generateCrudService(): string {
  return `import prisma from '../lib/prisma.js';
import { getPaginationParams, createPaginatedResult, type PaginationOptions } from '../lib/db-utils.js';

/**
 * Generic CRUD service factory
 * Use this as a base for your model services
 */
export function createCrudService<T, CreateInput, UpdateInput>(
  modelName: string,
  options: {
    defaultInclude?: object;
    defaultOrderBy?: object;
  } = {}
) {
  const model = (prisma as any)[modelName];
  
  if (!model) {
    throw new Error(\`Model "\${modelName}" not found in Prisma client\`);
  }
  
  return {
    async findMany(
      where: object = {},
      pagination?: PaginationOptions
    ) {
      if (pagination) {
        const { skip, take, page, pageSize } = getPaginationParams(pagination);
        
        const [data, total] = await Promise.all([
          model.findMany({
            where,
            skip,
            take,
            include: options.defaultInclude,
            orderBy: options.defaultOrderBy,
          }),
          model.count({ where }),
        ]);
        
        return createPaginatedResult(data, total, page, pageSize);
      }
      
      return model.findMany({
        where,
        include: options.defaultInclude,
        orderBy: options.defaultOrderBy,
      });
    },
    
    async findById(id: string) {
      return model.findUnique({
        where: { id },
        include: options.defaultInclude,
      });
    },
    
    async findOne(where: object) {
      return model.findFirst({
        where,
        include: options.defaultInclude,
      });
    },
    
    async create(data: CreateInput) {
      return model.create({
        data,
        include: options.defaultInclude,
      });
    },
    
    async update(id: string, data: UpdateInput) {
      return model.update({
        where: { id },
        data,
        include: options.defaultInclude,
      });
    },
    
    async delete(id: string) {
      return model.delete({
        where: { id },
      });
    },
    
    async count(where: object = {}) {
      return model.count({ where });
    },
  };
}
`;
}

/**
 * Generate REST API generator from Prisma models
 */
export function generateRestApiGenerator(): string {
  return `import { Router, Request, Response, NextFunction } from 'express';
import { z } from 'zod';
import prisma from '../lib/prisma.js';
import { getPaginationParams, createPaginatedResult } from '../lib/db-utils.js';

/**
 * Generate REST API routes for a Prisma model
 * Similar to Supabase PostgREST but with Express
 */
export function createModelRouter(
  modelName: string,
  options: {
    /** Fields that can be filtered */
    filterableFields?: string[];
    /** Fields that can be sorted */
    sortableFields?: string[];
    /** Custom middleware for routes */
    middleware?: {
      all?: any[];
      get?: any[];
      post?: any[];
      put?: any[];
      delete?: any[];
    };
    /** Disable specific operations */
    disable?: ('list' | 'get' | 'create' | 'update' | 'delete')[];
  } = {}
) {
  const router = Router();
  const model = (prisma as any)[modelName];
  
  if (!model) {
    throw new Error(\`Model "\${modelName}" not found in Prisma client\`);
  }
  
  const disabled = new Set(options.disable || []);
  const filterableFields = new Set(options.filterableFields || []);
  const sortableFields = new Set(options.sortableFields || []);
  
  // Apply global middleware
  if (options.middleware?.all) {
    router.use(...options.middleware.all);
  }
  
  // Parse query filters
  const parseFilters = (query: any) => {
    const where: any = {};
    
    for (const [key, value] of Object.entries(query)) {
      if (key.startsWith('_')) continue; // Skip special params
      if (!filterableFields.has(key) && filterableFields.size > 0) continue;
      
      // Handle operators: field.eq, field.gt, field.contains, etc.
      const [field, op] = key.split('.');
      
      if (op) {
        switch (op) {
          case 'eq': where[field] = value; break;
          case 'neq': where[field] = { not: value }; break;
          case 'gt': where[field] = { gt: value }; break;
          case 'gte': where[field] = { gte: value }; break;
          case 'lt': where[field] = { lt: value }; break;
          case 'lte': where[field] = { lte: value }; break;
          case 'contains': where[field] = { contains: value, mode: 'insensitive' }; break;
          case 'startsWith': where[field] = { startsWith: value, mode: 'insensitive' }; break;
          case 'endsWith': where[field] = { endsWith: value, mode: 'insensitive' }; break;
          case 'in': where[field] = { in: String(value).split(',') }; break;
          case 'isNull': where[field] = value === 'true' ? null : { not: null }; break;
        }
      } else {
        where[field] = value;
      }
    }
    
    return where;
  };
  
  // Parse sorting
  const parseSorting = (query: any) => {
    const sort = query._sort || query.sort;
    const order = query._order?.toLowerCase() === 'desc' ? 'desc' : 'asc';
    
    if (sort && (sortableFields.has(sort) || sortableFields.size === 0)) {
      return { [sort]: order };
    }
    
    return { createdAt: 'desc' };
  };
  
  // LIST - GET /
  if (!disabled.has('list')) {
    const listMiddleware = options.middleware?.get || [];
    router.get('/', ...listMiddleware, async (req: Request, res: Response, next: NextFunction) => {
      try {
        const where = parseFilters(req.query);
        const orderBy = parseSorting(req.query);
        const { skip, take, page, pageSize } = getPaginationParams({
          page: parseInt(req.query._page as string) || 1,
          pageSize: parseInt(req.query._limit as string) || 20,
        });
        
        const [data, total] = await Promise.all([
          model.findMany({ where, orderBy, skip, take }),
          model.count({ where }),
        ]);
        
        const result = createPaginatedResult(data, total, page, pageSize);
        
        // Set pagination headers (like Supabase)
        res.setHeader('X-Total-Count', total);
        res.setHeader('X-Page', page);
        res.setHeader('X-Page-Size', pageSize);
        
        res.json(result);
      } catch (error) {
        next(error);
      }
    });
  }
  
  // GET by ID - GET /:id
  if (!disabled.has('get')) {
    const getMiddleware = options.middleware?.get || [];
    router.get('/:id', ...getMiddleware, async (req: Request, res: Response, next: NextFunction) => {
      try {
        const item = await model.findUnique({ where: { id: req.params.id } });
        
        if (!item) {
          return res.status(404).json({ error: 'Not found' });
        }
        
        res.json(item);
      } catch (error) {
        next(error);
      }
    });
  }
  
  // CREATE - POST /
  if (!disabled.has('create')) {
    const postMiddleware = options.middleware?.post || [];
    router.post('/', ...postMiddleware, async (req: Request, res: Response, next: NextFunction) => {
      try {
        const item = await model.create({ data: req.body });
        res.status(201).json(item);
      } catch (error) {
        next(error);
      }
    });
  }
  
  // UPDATE - PUT /:id
  if (!disabled.has('update')) {
    const putMiddleware = options.middleware?.put || [];
    router.put('/:id', ...putMiddleware, async (req: Request, res: Response, next: NextFunction) => {
      try {
        const item = await model.update({
          where: { id: req.params.id },
          data: req.body,
        });
        res.json(item);
      } catch (error: any) {
        if (error.code === 'P2025') {
          return res.status(404).json({ error: 'Not found' });
        }
        next(error);
      }
    });
    
    // PATCH also supported
    router.patch('/:id', ...putMiddleware, async (req: Request, res: Response, next: NextFunction) => {
      try {
        const item = await model.update({
          where: { id: req.params.id },
          data: req.body,
        });
        res.json(item);
      } catch (error: any) {
        if (error.code === 'P2025') {
          return res.status(404).json({ error: 'Not found' });
        }
        next(error);
      }
    });
  }
  
  // DELETE - DELETE /:id
  if (!disabled.has('delete')) {
    const deleteMiddleware = options.middleware?.delete || [];
    router.delete('/:id', ...deleteMiddleware, async (req: Request, res: Response, next: NextFunction) => {
      try {
        await model.delete({ where: { id: req.params.id } });
        res.status(204).send();
      } catch (error: any) {
        if (error.code === 'P2025') {
          return res.status(404).json({ error: 'Not found' });
        }
        next(error);
      }
    });
  }
  
  return router;
}
`;
}
