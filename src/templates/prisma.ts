/**
 * Prisma ORM templates for self-hosted database
 */

import type { SelfHostedConfig } from '../config.js';

export interface PrismaOptions {
  config: SelfHostedConfig;
  additionalModels?: string;
}

/**
 * Generate Prisma schema with User, RefreshToken, and FileStorage models
 */
export function generatePrismaSchema(options: PrismaOptions): string {
  const { config } = options;
  const additionalModels = options.additionalModels || '';
  
  return `// Prisma Schema for Self-Hosted Backend
// Generated by Deno-Express Converter

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// Authentication Models
// ============================================

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  passwordHash  String    @map("password_hash")
  emailVerified Boolean   @default(false) @map("email_verified")
  
  // Profile fields
  fullName      String?   @map("full_name")
  avatarUrl     String?   @map("avatar_url")
  
  // Metadata (JSON field for flexible data)
  metadata      Json      @default("{}")
  
  // Timestamps
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")
  lastSignInAt  DateTime? @map("last_sign_in_at")
  
  // Relations
  refreshTokens RefreshToken[]
  files         FileStorage[]
  
  @@map("users")
}

model RefreshToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String   @map("user_id")
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")
  
  // Device/Session info
  userAgent String?  @map("user_agent")
  ipAddress String?  @map("ip_address")
  
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
  @@index([expiresAt])
  @@map("refresh_tokens")
}

// ============================================
// File Storage Models
// ============================================

model FileStorage {
  id          String   @id @default(cuid())
  bucket      String   @default("default")
  path        String
  filename    String
  mimeType    String   @map("mime_type")
  size        Int
  
  // Storage provider info
  provider    String   @default("local") // 'local' or 'minio'
  storageKey  String   @map("storage_key") // actual file path/key
  
  // Ownership
  userId      String?  @map("user_id")
  user        User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  
  // Access control
  isPublic    Boolean  @default(false) @map("is_public")
  
  // Timestamps
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")
  
  @@unique([bucket, path, filename])
  @@index([userId])
  @@index([bucket])
  @@map("file_storage")
}

// ============================================
// Session Model (for server-side sessions)
// ============================================

model Session {
  id        String   @id @default(cuid())
  userId    String   @map("user_id")
  data      Json     @default("{}")
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")
  
  @@index([userId])
  @@index([expiresAt])
  @@map("sessions")
}

${additionalModels}
`;
}

/**
 * Generate DATABASE_URL from config
 */
export function generateDatabaseUrl(config: SelfHostedConfig): string {
  const db = config.database || {};
  const host = db.host || 'localhost';
  const port = db.port || 5432;
  const name = db.name || 'app_db';
  const user = db.user || 'postgres';
  const password = db.password || 'postgres';
  
  return `postgresql://${user}:${password}@${host}:${port}/${name}?schema=public`;
}

/**
 * Generate Prisma client initialization code
 */
export function generatePrismaClient(): string {
  return `import { PrismaClient } from '@prisma/client';

// Global Prisma client instance (prevents multiple instances in development)
declare global {
  var __prisma: PrismaClient | undefined;
}

const prismaClientSingleton = () => {
  return new PrismaClient({
    log: process.env.NODE_ENV === 'development' 
      ? ['query', 'error', 'warn'] 
      : ['error'],
  });
};

export const prisma = globalThis.__prisma ?? prismaClientSingleton();

if (process.env.NODE_ENV !== 'production') {
  globalThis.__prisma = prisma;
}

// Graceful shutdown
process.on('beforeExit', async () => {
  await prisma.$disconnect();
});

export default prisma;
`;
}

/**
 * Generate database helper utilities
 */
export function generateDbUtils(): string {
  return `import prisma from './prisma.js';

/**
 * Health check for database connection
 */
export async function checkDatabaseHealth(): Promise<boolean> {
  try {
    await prisma.$queryRaw\`SELECT 1\`;
    return true;
  } catch (error) {
    console.error('Database health check failed:', error);
    return false;
  }
}

/**
 * Paginated query helper
 */
export interface PaginationOptions {
  page?: number;
  pageSize?: number;
  maxPageSize?: number;
}

export interface PaginatedResult<T> {
  data: T[];
  pagination: {
    page: number;
    pageSize: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };
}

export function getPaginationParams(options: PaginationOptions = {}) {
  const page = Math.max(1, options.page || 1);
  const maxSize = options.maxPageSize || 100;
  const pageSize = Math.min(Math.max(1, options.pageSize || 20), maxSize);
  
  return {
    skip: (page - 1) * pageSize,
    take: pageSize,
    page,
    pageSize,
  };
}

export function createPaginatedResult<T>(
  data: T[],
  total: number,
  page: number,
  pageSize: number
): PaginatedResult<T> {
  const totalPages = Math.ceil(total / pageSize);
  
  return {
    data,
    pagination: {
      page,
      pageSize,
      total,
      totalPages,
      hasNext: page < totalPages,
      hasPrev: page > 1,
    },
  };
}

/**
 * Transaction helper with automatic rollback on error
 */
export async function withTransaction<T>(
  fn: (tx: typeof prisma) => Promise<T>
): Promise<T> {
  return prisma.$transaction(async (tx) => {
    return fn(tx as typeof prisma);
  });
}
`;
}

/**
 * Generate generic CRUD service template
 */
export function generateCrudService(): string {
  return `import prisma from '../lib/prisma.js';
import { getPaginationParams, createPaginatedResult, type PaginationOptions } from '../lib/db-utils.js';

/**
 * Generic CRUD service factory
 * Use this as a base for your model services
 */
export function createCrudService<T, CreateInput, UpdateInput>(
  modelName: string,
  options: {
    defaultInclude?: object;
    defaultOrderBy?: object;
  } = {}
) {
  const model = (prisma as any)[modelName];
  
  if (!model) {
    throw new Error(\`Model "\${modelName}" not found in Prisma client\`);
  }
  
  return {
    async findMany(
      where: object = {},
      pagination?: PaginationOptions
    ) {
      if (pagination) {
        const { skip, take, page, pageSize } = getPaginationParams(pagination);
        
        const [data, total] = await Promise.all([
          model.findMany({
            where,
            skip,
            take,
            include: options.defaultInclude,
            orderBy: options.defaultOrderBy,
          }),
          model.count({ where }),
        ]);
        
        return createPaginatedResult(data, total, page, pageSize);
      }
      
      return model.findMany({
        where,
        include: options.defaultInclude,
        orderBy: options.defaultOrderBy,
      });
    },
    
    async findById(id: string) {
      return model.findUnique({
        where: { id },
        include: options.defaultInclude,
      });
    },
    
    async findOne(where: object) {
      return model.findFirst({
        where,
        include: options.defaultInclude,
      });
    },
    
    async create(data: CreateInput) {
      return model.create({
        data,
        include: options.defaultInclude,
      });
    },
    
    async update(id: string, data: UpdateInput) {
      return model.update({
        where: { id },
        data,
        include: options.defaultInclude,
      });
    },
    
    async delete(id: string) {
      return model.delete({
        where: { id },
      });
    },
    
    async count(where: object = {}) {
      return model.count({ where });
    },
  };
}
`;
}

/**
 * Generate REST API generator from Prisma models
 */
export function generateRestApiGenerator(): string {
  return `import { Router, Request, Response, NextFunction } from 'express';
import { z } from 'zod';
import prisma from '../lib/prisma.js';
import { getPaginationParams, createPaginatedResult } from '../lib/db-utils.js';

/**
 * Generate REST API routes for a Prisma model
 * Similar to Supabase PostgREST but with Express
 */
export function createModelRouter(
  modelName: string,
  options: {
    /** Fields that can be filtered */
    filterableFields?: string[];
    /** Fields that can be sorted */
    sortableFields?: string[];
    /** Custom middleware for routes */
    middleware?: {
      all?: any[];
      get?: any[];
      post?: any[];
      put?: any[];
      delete?: any[];
    };
    /** Disable specific operations */
    disable?: ('list' | 'get' | 'create' | 'update' | 'delete')[];
  } = {}
) {
  const router = Router();
  const model = (prisma as any)[modelName];
  
  if (!model) {
    throw new Error(\`Model "\${modelName}" not found in Prisma client\`);
  }
  
  const disabled = new Set(options.disable || []);
  const filterableFields = new Set(options.filterableFields || []);
  const sortableFields = new Set(options.sortableFields || []);
  
  // Apply global middleware
  if (options.middleware?.all) {
    router.use(...options.middleware.all);
  }
  
  // Parse query filters
  const parseFilters = (query: any) => {
    const where: any = {};
    
    for (const [key, value] of Object.entries(query)) {
      if (key.startsWith('_')) continue; // Skip special params
      if (!filterableFields.has(key) && filterableFields.size > 0) continue;
      
      // Handle operators: field.eq, field.gt, field.contains, etc.
      const [field, op] = key.split('.');
      
      if (op) {
        switch (op) {
          case 'eq': where[field] = value; break;
          case 'neq': where[field] = { not: value }; break;
          case 'gt': where[field] = { gt: value }; break;
          case 'gte': where[field] = { gte: value }; break;
          case 'lt': where[field] = { lt: value }; break;
          case 'lte': where[field] = { lte: value }; break;
          case 'contains': where[field] = { contains: value, mode: 'insensitive' }; break;
          case 'startsWith': where[field] = { startsWith: value, mode: 'insensitive' }; break;
          case 'endsWith': where[field] = { endsWith: value, mode: 'insensitive' }; break;
          case 'in': where[field] = { in: String(value).split(',') }; break;
          case 'isNull': where[field] = value === 'true' ? null : { not: null }; break;
        }
      } else {
        where[field] = value;
      }
    }
    
    return where;
  };
  
  // Parse sorting
  const parseSorting = (query: any) => {
    const sort = query._sort || query.sort;
    const order = query._order?.toLowerCase() === 'desc' ? 'desc' : 'asc';
    
    if (sort && (sortableFields.has(sort) || sortableFields.size === 0)) {
      return { [sort]: order };
    }
    
    return { createdAt: 'desc' };
  };
  
  // LIST - GET /
  if (!disabled.has('list')) {
    const listMiddleware = options.middleware?.get || [];
    router.get('/', ...listMiddleware, async (req: Request, res: Response, next: NextFunction) => {
      try {
        const where = parseFilters(req.query);
        const orderBy = parseSorting(req.query);
        const { skip, take, page, pageSize } = getPaginationParams({
          page: parseInt(req.query._page as string) || 1,
          pageSize: parseInt(req.query._limit as string) || 20,
        });
        
        const [data, total] = await Promise.all([
          model.findMany({ where, orderBy, skip, take }),
          model.count({ where }),
        ]);
        
        const result = createPaginatedResult(data, total, page, pageSize);
        
        // Set pagination headers (like Supabase)
        res.setHeader('X-Total-Count', total);
        res.setHeader('X-Page', page);
        res.setHeader('X-Page-Size', pageSize);
        
        res.json(result);
      } catch (error) {
        next(error);
      }
    });
  }
  
  // GET by ID - GET /:id
  if (!disabled.has('get')) {
    const getMiddleware = options.middleware?.get || [];
    router.get('/:id', ...getMiddleware, async (req: Request, res: Response, next: NextFunction) => {
      try {
        const item = await model.findUnique({ where: { id: req.params.id } });
        
        if (!item) {
          return res.status(404).json({ error: 'Not found' });
        }
        
        res.json(item);
      } catch (error) {
        next(error);
      }
    });
  }
  
  // CREATE - POST /
  if (!disabled.has('create')) {
    const postMiddleware = options.middleware?.post || [];
    router.post('/', ...postMiddleware, async (req: Request, res: Response, next: NextFunction) => {
      try {
        const item = await model.create({ data: req.body });
        res.status(201).json(item);
      } catch (error) {
        next(error);
      }
    });
  }
  
  // UPDATE - PUT /:id
  if (!disabled.has('update')) {
    const putMiddleware = options.middleware?.put || [];
    router.put('/:id', ...putMiddleware, async (req: Request, res: Response, next: NextFunction) => {
      try {
        const item = await model.update({
          where: { id: req.params.id },
          data: req.body,
        });
        res.json(item);
      } catch (error: any) {
        if (error.code === 'P2025') {
          return res.status(404).json({ error: 'Not found' });
        }
        next(error);
      }
    });
    
    // PATCH also supported
    router.patch('/:id', ...putMiddleware, async (req: Request, res: Response, next: NextFunction) => {
      try {
        const item = await model.update({
          where: { id: req.params.id },
          data: req.body,
        });
        res.json(item);
      } catch (error: any) {
        if (error.code === 'P2025') {
          return res.status(404).json({ error: 'Not found' });
        }
        next(error);
      }
    });
  }
  
  // DELETE - DELETE /:id
  if (!disabled.has('delete')) {
    const deleteMiddleware = options.middleware?.delete || [];
    router.delete('/:id', ...deleteMiddleware, async (req: Request, res: Response, next: NextFunction) => {
      try {
        await model.delete({ where: { id: req.params.id } });
        res.status(204).send();
      } catch (error: any) {
        if (error.code === 'P2025') {
          return res.status(404).json({ error: 'Not found' });
        }
        next(error);
      }
    });
  }
  
  return router;
}
`;
}

/**
 * Generate a dynamic REST API router that handles any table (PostgREST-compatible)
 */
export function generateDynamicRestApi(): string {
  return `import { Router, Request, Response, NextFunction } from 'express';
import prisma from '../lib/prisma.js';

const router = Router();

/**
 * Convert snake_case to camelCase (for Prisma model names only)
 */
function toCamelCase(str: string): string {
  return str.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
}

/**
 * Get Prisma model by table name (handles both snake_case and camelCase)
 */
function getPrismaModel(tableName: string): any {
  const camelCaseName = toCamelCase(tableName);
  const model = (prisma as any)[camelCaseName] || (prisma as any)[tableName];
  return model;
}

/**
 * Check if a string looks like a date (YYYY-MM-DD or similar patterns)
 */
function isDateString(value: string): boolean {
  // Match YYYY-MM-DD format
  if (/^\d{4}-\d{2}-\d{2}$/.test(value)) return true;
  // Match YYYY-MM-DDTHH:MM:SS (already ISO format)
  if (/^\d{4}-\d{2}-\d{2}T/.test(value)) return true;
  return false;
}

/**
 * Convert date strings to ISO-8601 DateTime format for Prisma
 * Handles: "2026-02-16" -> "2026-02-16T00:00:00.000Z"
 */
function convertDates(data: any): any {
  if (data === null || data === undefined) return data;
  
  if (typeof data === 'string') {
    // Convert date-only strings to full ISO DateTime
    if (/^\d{4}-\d{2}-\d{2}$/.test(data)) {
      return new Date(data + 'T00:00:00.000Z').toISOString();
    }
    return data;
  }
  
  if (Array.isArray(data)) {
    return data.map(item => convertDates(item));
  }
  
  if (typeof data === 'object') {
    const converted: any = {};
    for (const [key, value] of Object.entries(data)) {
      // Check if key suggests it's a date field
      const isDateField = key.toLowerCase().includes('date') || 
                          key.toLowerCase().includes('_at') ||
                          key === 'created_at' || 
                          key === 'updated_at' ||
                          key === 'createdAt' ||
                          key === 'updatedAt';
      
      if (isDateField && typeof value === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(value)) {
        converted[key] = new Date(value + 'T00:00:00.000Z').toISOString();
      } else {
        converted[key] = convertDates(value);
      }
    }
    return converted;
  }
  
  return data;
}

/**
 * Parse query string filters from Supabase-style format
 * Field names are kept as-is (don't convert to camelCase)
 */
function parseFilters(query: Record<string, any>): Record<string, any> {
  const where: any = {};
  
  for (const [key, value] of Object.entries(query)) {
    // Skip special params
    if (key.startsWith('_') || key === 'select' || key === 'order') continue;
    
    // Parse PostgREST-style operators
    // Supabase format: column=eq.value, column=gt.value, etc.
    const stringValue = String(value);
    
    // Check for operatorprefix
    if (stringValue.includes('.')) {
      const dotIndex = stringValue.indexOf('.');
      const op = stringValue.substring(0, dotIndex);
      const val = stringValue.substring(dotIndex + 1);
      
      switch (op) {
        case 'eq': where[key] = val; break;
        case 'neq': where[key] = { not: val }; break;
        case 'gt': where[key] = { gt: isNaN(Number(val)) ? val : Number(val) }; break;
        case 'gte': where[key] = { gte: isNaN(Number(val)) ? val : Number(val) }; break;
        case 'lt': where[key] = { lt: isNaN(Number(val)) ? val : Number(val) }; break;
        case 'lte': where[key] = { lte: isNaN(Number(val)) ? val : Number(val) }; break;
        case 'like': where[key] = { contains: val.replace(/%/g, ''), mode: 'insensitive' }; break;
        case 'ilike': where[key] = { contains: val.replace(/%/g, ''), mode: 'insensitive' }; break;
        case 'is': where[key] = val === 'null' ? null : val; break;
        case 'in': where[key] = { in: val.slice(1, -1).split(',') }; break;
        case 'not':
          // Handle not.eq, not.in, etc.
          if (val.startsWith('eq.')) {
            where[key] = { not: val.substring(3) };
          } else if (val.startsWith('in.')) {
            where[key] = { notIn: val.slice(4, -1).split(',') };
          }
          break;
        default:
          // Plain value
          where[key] = value;
      }
    } else {
      // Simple equality filter (no conversion needed)
      where[key] = value;
    }
  }
  
  return where;
}

/**
 * Parse select fields - keep field names as-is
 */
function parseSelect(selectParam: string | undefined): Record<string, boolean> | undefined {
  if (!selectParam) return undefined;
  
  const fields = selectParam.split(',').map(f => f.trim());
  const select: Record<string, boolean> = {};
  
  for (const field of fields) {
    if (field && !field.includes('(')) { // Skip relation selects for now
      // Keep field name as-is (don't convert)
      select[field] = true;
    }
  }
  
  return Object.keys(select).length > 0 ? select : undefined;
}

/**
 * Parse ordering - keep field names as-is
 */
function parseOrder(sortParam: string | undefined): any {
  if (!sortParam) return undefined;
  
  const orders: any[] = [];
  const parts = sortParam.split(',');
  
  for (const part of parts) {
    const [field, direction] = part.split(':');
    if (field) {
      // Keep field name as-is (don't convert to camelCase)
      orders.push({ [field.trim()]: direction?.toLowerCase() === 'desc' ? 'desc' : 'asc' });
    }
  }
  
  return orders.length > 0 ? orders : undefined;
}

// Dynamic REST API for any table
// GET /api/:table - List/query records
router.get('/:table', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { table } = req.params;
    const model = getPrismaModel(table);
    
    if (!model) {
      return res.status(404).json({ 
        error: 'Not Found', 
        message: \`Table "\${table}" not found. Available tables: \${Object.keys(prisma).filter(k => !k.startsWith('_') && !k.startsWith('$')).join(', ')}\`
      });
    }
    
    const where = parseFilters(req.query as Record<string, any>);
    const select = parseSelect(req.query._select as string || req.query.select as string);
    const orderBy = parseOrder(req.query._sort as string || req.query.order as string);
    const limit = parseInt(req.query._limit as string || req.query.limit as string) || 100;
    const offset = parseInt(req.query._offset as string || req.query.offset as string) || 0;
    
    const queryOptions: any = {
      where,
      take: limit,
      skip: offset,
    };
    
    if (select) queryOptions.select = select;
    if (orderBy) queryOptions.orderBy = orderBy;
    
    const data = await model.findMany(queryOptions);
    
    // Get total count for headers
    const total = await model.count({ where });
    
    res.setHeader('Content-Range', \`\${offset}-\${offset + data.length - 1}/\${total}\`);
    res.setHeader('X-Total-Count', total.toString());
    
    res.json(data);
  } catch (error: any) {
    console.error('Database query error:', error);
    next(error);
  }
});

// GET /api/:table/:id - Get single record
router.get('/:table/:id', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { table, id } = req.params;
    const model = getPrismaModel(table);
    
    if (!model) {
      return res.status(404).json({ error: 'Not Found', message: \`Table "\${table}" not found\` });
    }
    
    const item = await model.findUnique({ where: { id } });
    
    if (!item) {
      return res.status(404).json({ error: 'Not Found', message: 'Record not found' });
    }
    
    res.json(item);
  } catch (error) {
    next(error);
  }
});

// POST /api/:table - Create record
router.post('/:table', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { table } = req.params;
    const model = getPrismaModel(table);
    
    if (!model) {
      return res.status(404).json({ error: 'Not Found', message: \`Table "\${table}" not found\` });
    }
    
    // Convert date strings to ISO-8601 DateTime format
    const data = convertDates(req.body);
    
    const item = await model.create({ data });
    res.status(201).json(item);
  } catch (error) {
    next(error);
  }
});

// PATCH /api/:table/:id - Update record
router.patch('/:table/:id', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { table, id } = req.params;
    const model = getPrismaModel(table);
    
    if (!model) {
      return res.status(404).json({ error: 'Not Found', message: \`Table "\${table}" not found\` });
    }
    
    // Convert date strings to ISO-8601 DateTime format
    const data = convertDates(req.body);
    
    const item = await model.update({
      where: { id },
      data,
    });
    
    res.json(item);
  } catch (error: any) {
    if (error.code === 'P2025') {
      return res.status(404).json({ error: 'Not Found', message: 'Record not found' });
    }
    next(error);
  }
});

// DELETE /api/:table/:id - Delete record
router.delete('/:table/:id', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { table, id } = req.params;
    const model = getPrismaModel(table);
    
    if (!model) {
      return res.status(404).json({ error: 'Not Found', message: \`Table "\${table}" not found\` });
    }
    
    await model.delete({ where: { id } });
    res.status(204).send();
  } catch (error: any) {
    if (error.code === 'P2025') {
      return res.status(404).json({ error: 'Not Found', message: 'Record not found' });
    }
    next(error);
  }
});

export default router;
`;
}

/**
 * Generate RPC handler for Supabase-style RPC calls
 */
export function generateRpcHandler(): string {
  return `import { Router, Request, Response, NextFunction } from 'express';
import prisma from '../lib/prisma.js';

const router = Router();

// Map of RPC function names to their implementations
// Add your custom RPC functions here
const rpcFunctions: Record<string, (params: any, userId?: string) => Promise<any>> = {
  // Example: is_system_admin checks if a user has system admin role
  is_system_admin: async (params, userId) => {
    if (!userId) return false;
    
    try {
      const user = await prisma.user.findUnique({
        where: { id: userId },
        include: { role: true },
      });
      
      return user?.role?.name === 'System Admin' || user?.role?.name === 'system_admin';
    } catch {
      return false;
    }
  },
  
  // Add more RPC functions as needed
};

// POST /rpc/:functionName - Call RPC function
router.post('/:functionName', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { functionName } = req.params;
    const func = rpcFunctions[functionName];
    
    if (!func) {
      return res.status(404).json({ 
        error: 'Not Found', 
        message: \`RPC function "\${functionName}" not found. To add this function, edit src/routes/rpc.ts\`
      });
    }
    
    // Get user ID from auth if available
    const userId = (req as any).user?.id;
    
    const result = await func(req.body, userId);
    res.json(result);
  } catch (error) {
    next(error);
  }
});

// GET /rpc/:functionName - Also support GET
router.get('/:functionName', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { functionName } = req.params;
    const func = rpcFunctions[functionName];
    
    if (!func) {
      return res.status(404).json({ 
        error: 'Not Found', 
        message: \`RPC function "\${functionName}" not found\`
      });
    }
    
    const userId = (req as any).user?.id;
    const result = await func(req.query, userId);
    res.json(result);
  } catch (error) {
    next(error);
  }
});

export default router;
`;
}

